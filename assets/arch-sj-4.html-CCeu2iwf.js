import{_ as l,o as i,c as u,e as t}from"./app-n0xwCUxG.js";const h={},s=t('<h2 id="_14、服务化-微服务架构-究竟解决什么问题" tabindex="-1"><a class="header-anchor" href="#_14、服务化-微服务架构-究竟解决什么问题" aria-hidden="true">#</a> 14、服务化：微服务架构，究竟解决什么问题？</h2><ul><li>no14：在服务化前后的互联网的常见架构示意图 <ul><li>服务化前</li><li><img src="https://img.shiqi-lu.tech/20210906114646.png" alt=""></li><li>服务化后</li><li><img src="https://img.shiqi-lu.tech/20210906200739.png" alt=""></li></ul></li><li>no14：没有服务化前的痛点 <ul><li>1.代码到处拷贝 <ul><li><img src="https://img.shiqi-lu.tech/20210906114751.png" alt=""></li></ul></li><li>2.底层复杂性扩散 <ul><li><img src="https://img.shiqi-lu.tech/20210906114828.png" alt=""></li></ul></li><li>3.公共库耦合</li><li>4.SQL 质量无法保障 <ul><li><img src="https://img.shiqi-lu.tech/20210906200420.png" alt=""></li></ul></li><li>5.不易扩展，数据库耦合 <ul><li><img src="https://img.shiqi-lu.tech/20210906200628.png" alt=""></li></ul></li></ul></li><li>no14：服务化的好处 <ul><li>1.复用性，消除代码拷贝 <ul><li><img src="https://img.shiqi-lu.tech/20210906200847.png" alt=""></li></ul></li><li>2.专注性，防止复杂性扩散 <ul><li><img src="https://img.shiqi-lu.tech/20210906200929.png" alt=""></li></ul></li><li>3.解耦合，消除公共库耦合</li><li>4.高质量，SQL 稳定性有保障 <ul><li><img src="https://img.shiqi-lu.tech/20210906201132.png" alt=""></li></ul></li><li>5.易扩展，消除数据库解耦合</li><li>6.(最重要)高效，对业务调用方的研发效率提升了</li></ul></li><li>no14：服务化后的潜在问题有哪些？ <ul><li>1.系统复杂性上升</li><li>2.层次间依赖关系变得复杂</li><li>3.运维，部署更麻烦</li><li>4.监控变得更复杂</li><li>5.定位问题更麻烦</li></ul></li></ul><h2 id="_15、服务化-微服务架构-粒度多少合适" tabindex="-1"><a class="header-anchor" href="#_15、服务化-微服务架构-粒度多少合适" aria-hidden="true">#</a> 15、服务化：微服务架构，粒度多少合适？</h2><ul><li>no15：微服务化架构粒度拆分实践一：统一服务层 <ul><li><img src="https://img.shiqi-lu.tech/20210907042437.png" alt=""></li><li>业务不是特别复杂的时候，统一整个服务层，所有数据都通过一个统一的服务层来进行访问</li><li>缺点：一旦代码出故障，就将影响整个服务</li></ul></li><li>no15：微服务化架构粒度拆分实践二：一个子业务一个服务(最佳实践) <ul><li><img src="https://img.shiqi-lu.tech/20210907042536.png" alt=""></li><li>在服务层进行垂直拆分，一个子业务抽象出一个服务，数据层也按照子业务垂直拆分</li><li>当业务连接关系变得复杂时，加入网关分发层来消除这个网状关系，并在协议设计的时候加入一个协议号服务号，分发层通过协议号服务号将请求路由到相关的子业务服务</li><li><img src="https://img.shiqi-lu.tech/20210907043051.png" alt=""></li></ul></li><li>no15：微服务化架构粒度拆分实践三：一个数据库一个服务 <ul><li><img src="https://img.shiqi-lu.tech/20210907043722.png" alt=""></li></ul></li><li>no15：微服务化架构粒度拆分实践四：一个接口一个服务 <ul><li><img src="https://img.shiqi-lu.tech/20210907044101.png" alt=""></li><li>需要语言特性的支持，如 go 可以这么使用</li></ul></li><li>no15：微服务化架构拆成细粒度优缺点 <ul><li>优点 <ul><li>服务能够独立部署，扩容缩容相对方便</li><li>能更有效地提高资源利用率</li><li>耦合度相对减小</li><li>容错性相对更好</li><li>扩展性也会更好</li></ul></li><li>缺点 <ul><li>服务数量变多</li><li>系统复杂性增加</li><li>依赖关系复杂性增加</li><li>运维复杂性增加</li><li>监控更复杂</li><li>定位问题更复杂</li></ul></li></ul></li></ul><h2 id="_16、服务化-微服务架构-必须搞定高可用" tabindex="-1"><a class="header-anchor" href="#_16、服务化-微服务架构-必须搞定高可用" aria-hidden="true">#</a> 16、服务化：微服务架构，必须搞定高可用！</h2><ul><li>no16：高可用是什么？ <ul><li>减少系统不能提供服务的时间</li></ul></li><li>no16：如何判断是否高可用？ <ul><li>随机关停一台线上服务器，如果对用户的服务不受影响，那么系统就是高可用的</li></ul></li><li>no16：如何保障系统的高可用 <ul><li>1.集群化(冗余)</li><li>2.故障自动转移</li></ul></li><li>no16：常见微服务分层架构？ <ul><li><img src="https://img.shiqi-lu.tech/20210908092416.png" alt=""></li></ul></li><li>no16：微服务分层架构如何保证「端」到「反向代理」的高可用 <ul><li><img src="https://img.shiqi-lu.tech/20210908092543.png" alt=""></li><li>通过 keepalived + 虚 IP 来实现</li></ul></li><li>no16：微服务分层架构如何保证「反向代理」到「站点应用」的高可用 <ul><li><img src="https://img.shiqi-lu.tech/20210908092644.png" alt=""></li><li>通过站点层的冗余来实现</li></ul></li><li>no16：微服务分层架构如何保证「站点应用」到「微服务」的高可用 <ul><li><img src="https://img.shiqi-lu.tech/20210908092931.png" alt=""></li><li>通过服务层的冗余来实现，上游有服务连接池</li></ul></li><li>no16：微服务分层架构如何保证「微服务」到「缓存」的高可用(memcache) <ul><li><img src="https://img.shiqi-lu.tech/20210908093051.png" alt=""></li></ul></li><li>no16：微服务分层架构如何保证「微服务」到「缓存」的高可用(redis) <ul><li><img src="https://img.shiqi-lu.tech/20210908093155.png" alt=""></li><li>但很多时候缓存不需要保证高可用，只要不「雪崩」压垮数据库就行 <ul><li><img src="https://img.shiqi-lu.tech/20210908093429.png" alt=""></li><li>将缓存进行水平切分，这也是个集群，但只是用来做分片，并不做数据冗余，在上游设置代理，即进行完水平切分的入口</li></ul></li></ul></li><li>no16：微服务分层架构如何保证「微服务」到「数据库」的高可用 <ul><li>如果做了读写分离，必须保证</li><li>「微服务」到「读库」的高可用 <ul><li><img src="https://img.shiqi-lu.tech/20210908094009.png" alt=""></li><li>通过读库的冗余化集群实现的</li></ul></li><li>「微服务」到「写库」的高可用 <ul><li><img src="https://img.shiqi-lu.tech/20210908094226.png" alt=""></li><li>通过写库的冗余化集群实现的，如 MySQL 可通过设置双主相互同步</li></ul></li></ul></li></ul><h2 id="_17、服务化-微服务架构-必须搞定高并发" tabindex="-1"><a class="header-anchor" href="#_17、服务化-微服务架构-必须搞定高并发" aria-hidden="true">#</a> 17、服务化：微服务架构，必须搞定高并发！</h2><ul><li>no17：什么是高并发？ <ul><li>通过设计方案，保证系统能够同时并行的处理很多用户的很多请求</li></ul></li><li>no17：高并发相关的常见指标有哪些？ <ul><li>1.响应时间(Response Time)</li><li>2.吞吐量(Throughput)</li><li>3.每秒查询率 QPS(Query Per Second)</li><li>4.并发用户数</li></ul></li><li>no17：提升系统并发处理能力的方法论？ <ul><li>1.垂直扩展(Scale Up) <ul><li>1.提升单机硬件性能</li><li>2.提升单机架构性能</li><li>业务早期建议使用，因为速度最快</li></ul></li><li>2.水平扩展(Scale Out)</li></ul></li><li>no17：常见微服务分层架构 <ul><li><img src="https://img.shiqi-lu.tech/20210908104829.png" alt=""></li><li>要想做到整体的性能无限，就必须做到每一层都能够实现水平扩展性能无限</li></ul></li><li>no17：常见微服务分层架构的反向代理层的水平扩展 <ul><li><img src="https://img.shiqi-lu.tech/20210908104951.png" alt=""></li><li>之前都是通过 lvs 和 f5 的垂直扩展的方式，这都是有性能上限的，反向代理的水平扩展是通过 DNS 轮询实现的，DNS server 对于同一个域名配置不同的 nginx 外网 IP</li></ul></li><li>no17：常见微服务分层架构的站点应用层的水平扩展 <ul><li><img src="https://img.shiqi-lu.tech/20210908105303.png" alt=""></li><li>通过反向代理层实现</li></ul></li><li>no17：常见微服务分层架构的微服务的水平扩展 <ul><li><img src="https://img.shiqi-lu.tech/20210908105640.png" alt=""></li><li>通过服务连接池去实现的，站点层通过 rpc client 调用下层的服务层 rpc server，rpc client 会建立多个服务连接，当服务称为瓶颈的时候，只要增加服务节点的数量，rpc client 会建立新的连接</li></ul></li><li>no17：常见微服务分层架构的数据层(缓存，数据库)的水平扩展 <ul><li>需求 <ul><li>1.存储容量的扩展，无限容量</li><li>2.处理能力的扩展，无限读性能，无限写性能</li></ul></li><li>根据数据的范围水平切分 <ul><li><img src="https://img.shiqi-lu.tech/20210908110251.png" alt=""></li><li>优点 <ul><li>规则简单</li><li>数据的均衡性比较好</li><li>容易扩展</li></ul></li><li>缺点 <ul><li>虽然保证数据层是均衡的，但读写请求不一定是均衡的</li></ul></li></ul></li><li>按照哈希水平切分 <ul><li><img src="https://img.shiqi-lu.tech/20210908110615.png" alt=""></li><li>优点 <ul><li>规则简单</li><li>数据均衡性非常好</li><li>请求均衡性非常好</li></ul></li><li>缺点 <ul><li>不容易扩展，扩展可能需要进行数据迁移</li></ul></li></ul></li></ul></li></ul><h2 id="_18、服务化-微服务架构-必须搞定负载均衡" tabindex="-1"><a class="header-anchor" href="#_18、服务化-微服务架构-必须搞定负载均衡" aria-hidden="true">#</a> 18、服务化：微服务架构，必须搞定负载均衡！</h2><ul><li>no18：什么是负载均衡 <ul><li>将请求或者数据均匀地分摊到多个操作单元上执行 <ul><li>1.同构，重点在于「均匀」</li><li>2.异构，重点在于「负载与能力匹配」</li></ul></li></ul></li><li>no18：常见微服务分层架构，保证负载均衡的思路 <ul><li><img src="https://img.shiqi-lu.tech/20210908104829.png" alt=""></li><li>实现每个上游都实现对下游的均匀访问，即可实现系统整体的均匀分摊</li></ul></li><li>no18：常见微服务分层架构，反向代理层的负载均衡 <ul><li><img src="https://img.shiqi-lu.tech/20210908130356.png" alt=""></li><li>DNS 服务器使用 DNS 轮询的方式，即可实现 Nginx 的负载均衡</li></ul></li><li>no18：常见微服务分层架构，站点应用层的负载均衡 <ul><li><img src="https://img.shiqi-lu.tech/20210908130502.png" alt=""></li><li>nginx 使用轮询的方式，将请求路由到多个站点应用的后端</li></ul></li><li>no18：常见微服务分层架构，微服务的负载均衡 <ul><li><img src="https://img.shiqi-lu.tech/20210908135904.png" alt=""></li><li>通过连接池实现的，可使用随机或轮询等方式保证多个微服务的下游的请求是均匀的</li></ul></li><li>no18：常见微服务分层架构，数据层(缓存，数据库)的负载均衡 <ul><li>1.数据，均衡</li><li>2.请求，均衡</li><li>按照数据范围水平切分 <ul><li><img src="https://img.shiqi-lu.tech/20210908140119.png" alt=""></li><li>数据负载是均衡的，水平负载未必均衡，如新用户可能更活跃</li></ul></li><li>哈希水平切分 <ul><li><img src="https://img.shiqi-lu.tech/20210908140647.png" alt=""></li><li>数据、请求的负载都比较均衡，同构节点的服务器的均衡比较容易</li></ul></li></ul></li><li>no18：常见微服务分层架构，异构服务器负载均衡，方案一：静态权重 <ul><li><img src="https://img.shiqi-lu.tech/20210908141258.png" alt=""></li><li>为下游每个微服务节点设置一个静态权重，表示微服务的处理能力，来调配连接池</li><li>优点 <ul><li>简单粗暴</li></ul></li><li>缺点 <ul><li>无法自适应地去调节</li></ul></li></ul></li><li>no18：常见微服务分层架构，异构服务器负载均衡，方案二：动态权重 <ul><li>1.如何标识服务的处理能力？(下游的处理能力是由调用方决定的)</li><li>2.如何设计动态权重？</li><li>对每一个微服务的连接使用一个权重来标识，这个权重决定分配给每个微服务请求的概率，获得相应连接的概率，当下游每成功处理一个请求的时候，就认为下游的微服务的处理能力足够，增加权重(缓慢)，当微服务超时处理一个请求的时候，就认为下游的处理能力，可能要跟不上了，权重就减少(快速)</li><li>可把权重的范围设置为[0，100]之间，初始值设置为 60，</li></ul></li><li>no18：什么是过载保护？ <ul><li><img src="https://img.shiqi-lu.tech/20210908142320.png" alt=""></li><li>如果不对微服务实施过载保护，随着上游的负载越来越高，在微服务的处理能力范围内，每秒处理的请求是越来越高的</li><li>但是达到一个负载的极限时，外部负载持续的增加，它的处理能力会掉底，瞬间降为 0，即「雪崩」</li><li><img src="https://img.shiqi-lu.tech/20210908142533.png" alt=""></li><li>如果实施了过载保护，那么随着外部负载的增加，处理能力到达一个 max 值后，会保持相对稳定的一个值，系统不会被完全压垮</li></ul></li><li>no18：如何实施过载保护？ <ul><li>1.静态权重(粗暴，不优雅) <ul><li>给微服务的处理能力设置一个阈值，如果负载超过这个阈值，就将后续的请求全部抛弃</li></ul></li><li>2.动态权重 <ul><li>1.连接表示服务，分值代表服务(连接)</li><li>2.处理成功加小分，处理失败扣大分</li><li>3.到达临界编译时，如有请求超时的时候，可判断快要处理不过来了，让它有请求处理失败的时候休息一会，再接下来 10 秒内不再给这个超时的服务器进行负载分配</li><li>4.如果仍然连续地超时，可能判定这个服务器完全处理不过来了，如 fullGC，根据经验，fullGC 差不多一分钟之后能回过神，则一分钟后给它分配请求</li><li>但如果整体负载超过了微服务集群的整体负载，最终还是要抛弃部分请求</li></ul></li></ul></li></ul><h2 id="_20、服务化-连接池-高可用可扩展负载均衡都离不开他" tabindex="-1"><a class="header-anchor" href="#_20、服务化-连接池-高可用可扩展负载均衡都离不开他" aria-hidden="true">#</a> 20、服务化：连接池，高可用可扩展负载均衡都离不开他</h2><ul><li>no20：微服务分层架构中，连接池的位置 <ul><li><img src="https://img.shiqi-lu.tech/20210908201431.png" alt=""></li></ul></li><li>no20：高可用，故障转移，在连接池中是如何实现的？ <ul><li><img src="https://img.shiqi-lu.tech/20210908201526.png" alt=""></li><li>当有节点失效时，连接池重试也连接不上，则连接池会把失败的连接剔除出去</li></ul></li><li>no20：扩展性，服务发现，在连接池的实现 <ul><li>1.自动载入新服务节点的配置 <ul><li>方案一：监控配置文件，并重新载入 <ul><li>具体实现可以是启动一个进程，监控文件变化，循环检测文件 md5是否变化，如果变化则读取新服务节点的配置</li></ul></li><li>方案二：配置中心回调，并重新载入 <ul><li>每当调用方站点集群向配置中心注册了下游所依赖的微服务集群的配置，如果微服务集群的节点发生了变化配置中心会给调用方的站点集群进行回调，会将变化后的节点通知站点集群，再实施连接池自动增删节点</li></ul></li></ul></li><li>2.动态连接池</li></ul></li><li>no20：负载均衡，连接池的实现的三个方案 <ul><li>方案一：随机/轮询(同构服务器) <ul><li><img src="https://img.shiqi-lu.tech/20210908203120.png" alt=""></li></ul></li><li>方案二：静态权重法(异构服务器) <ul><li><img src="https://img.shiqi-lu.tech/20210908204445.png" alt=""></li></ul></li><li>方案二：动态权重法(异构服务器) <ul><li><img src="https://img.shiqi-lu.tech/20210908204559.png" alt=""></li></ul></li></ul></li></ul>',12),g=[s];function c(n,e){return i(),u("div",null,g)}const r=l(h,[["render",c],["__file","arch-sj-4.html.vue"]]);export{r as default};
