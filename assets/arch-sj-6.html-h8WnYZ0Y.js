import{_ as l,o as i,c as e,e as u}from"./app-n0xwCUxG.js";const t={},a=u('<h2 id="_27、缓存-进程内缓存要怎么玩" tabindex="-1"><a class="header-anchor" href="#_27、缓存-进程内缓存要怎么玩" aria-hidden="true">#</a> 27、缓存：进程内缓存要怎么玩？</h2><ul><li>no27：什么是进程内缓存？好处？不足？ <ul><li>定义 <ul><li>将数据缓存在站点或者服务的进程内，如 map 或 leveldb，可存 json、html、object 等</li></ul></li><li>好处 <ul><li>1.节省内网带宽</li><li>2.时延更低</li></ul></li><li>不足：一致性难以保证</li></ul></li><li>no27：如何保证进程内缓存的一致性？ <ul><li>方案一，单节点通知其它节点 <ul><li><img src="https://img.shiqi-lu.tech/20210915183312.png" alt=""></li><li>缺点 <ul><li>同一功能在集群内的多个节点相互耦合在一起，当节点比较多的时候，连接关系会相对比较复杂</li></ul></li></ul></li><li>方案二，MQ 解耦，通知其它节点 <ul><li><img src="https://img.shiqi-lu.tech/20210915183448.png" alt=""></li><li>缺点 <ul><li>接触了结点耦合，但引入了 mq，增加系统复杂度</li></ul></li></ul></li><li>方案三，放弃实时一致性，定期从后端更新数据 <ul><li><img src="https://img.shiqi-lu.tech/20210915183706.png" alt=""></li><li>缺点 <ul><li>必须一定程度上接受读旧数据</li></ul></li></ul></li></ul></li><li>no27：使用进程内缓存的场景是哪些？为什么不能频繁使用进程内缓存？ <ul><li>场景 <ul><li>1.只读数据</li><li>2.并发极高，透传后端压力极大</li><li>3.允许一定程度上数据不一致</li></ul></li><li>原因 <ul><li>违背了「站点无状态、服务无状态」的设计准则</li></ul></li></ul></li></ul><h2 id="_28、缓存-很多时候我们都用错了" tabindex="-1"><a class="header-anchor" href="#_28、缓存-很多时候我们都用错了" aria-hidden="true">#</a> 28、缓存：很多时候我们都用错了！</h2><ul><li>no28：缓存有哪 4 种误用的情况？ <ul><li>1.服务与服务之间不要通过缓存传递数据，数据传递使用 MQ 更合适 <ul><li><img src="https://img.shiqi-lu.tech/20210916114648.png" alt=""></li></ul></li><li>2.如果缓存挂掉，可能导致雪崩，此时要做高可用缓存，或者水平切分</li><li>3.调用方不宜再单独使用缓存存储服务底层的数据，容易出现数据不一致，以及反向依赖.</li><li>4.不同服务，缓存实例要做垂直拆分，不宜共用缓存 <ul><li><img src="https://img.shiqi-lu.tech/20210916114908.png" alt=""></li></ul></li></ul></li></ul><h2 id="_29、缓存-互联网最佳实践" tabindex="-1"><a class="header-anchor" href="#_29、缓存-互联网最佳实践" aria-hidden="true">#</a> 29、缓存：互联网最佳实践！</h2><ul><li>no29：互联网缓存最佳实践 Cache Aside Pattern 是什么？ <ul><li>读实践 <ul><li>先缓存，命中返回，未命中读数据库，再设置缓存</li><li><img src="https://img.shiqi-lu.tech/20210916205244.png" alt=""></li></ul></li><li>写实践 <ul><li>淘汰缓存而不是修改缓存，先操作数据库，而不是先淘汰缓存</li><li><img src="https://img.shiqi-lu.tech/20210916210847.png" alt=""></li></ul></li></ul></li></ul><h2 id="_30、缓存-一致性优化" tabindex="-1"><a class="header-anchor" href="#_30、缓存-一致性优化" aria-hidden="true">#</a> 30、缓存：一致性优化！</h2><ul><li>no30：数据库主从、数据库缓存什么时候会发生数据不一致问题？ <ul><li>数据库主从：写后立即读，短时间内，读旧数据 <ul><li><img src="https://img.shiqi-lu.tech/20210916212948.png" alt=""></li></ul></li><li>数据库缓存：写后立即读，短时间内，旧数据入缓存 <ul><li><img src="https://img.shiqi-lu.tech/20210916213008.png" alt=""></li></ul></li></ul></li><li>no30：缓存不一致的优化思路和两个方案是什么？ <ul><li>思路：在从库同步完成之后，如果有旧数据入缓存，应该及时把这个旧数据淘汰掉</li><li>方案一：二次淘汰法(在从库异步淘汰，或服务中异步淘汰) <ul><li><img src="https://img.shiqi-lu.tech/20210916213215.png" alt=""></li><li>通过工具订阅从库的 binlog，如 DTS 或 canal，或自己订阅和分析 binlog，然后从库执行异步淘汰缓存的操作</li></ul></li><li>方案二：为允许 cache miss 的场景，设定超时时间</li></ul></li></ul><h2 id="_31、缓存-并发更新的大坑" tabindex="-1"><a class="header-anchor" href="#_31、缓存-并发更新的大坑" aria-hidden="true">#</a> 31、缓存：并发更新的大坑！</h2><ul><li>no31：缓存并发更新获取 token 会出现什么问题？如何解决？ <ul><li>问题 <ul><li>两个并发请求的token申请，可能导致 token 迭代过期了</li><li><img src="https://img.shiqi-lu.tech/20210917100503.png" alt=""></li></ul></li><li>解决 <ul><li>线上服务 s1 和 s2 只从缓存中读取 token，token 的更新由一个异步的服务 asy-Master 定期更新，避免并发的更新</li><li>缺点 <ul><li>读取服务和更新的服务会直接调用缓存实例，如果缓存实例变更，读的服务和写的服务配置同步变更，导致耦合，违背了两个服务不应访问同一服务的通用性原则，同时违反了 cache aside pattern 的淘汰而不是更新缓存的设计准则</li></ul></li><li>数据存储在 DB，缓存应该淘汰，有时候，数据不在数据库，缓存需要更新，如调用第三方服务需要申请 token</li><li><img src="https://img.shiqi-lu.tech/20210917100642.png" alt=""></li></ul></li></ul></li></ul><h2 id="_32、缓存-究竟选redis-还是memcache" tabindex="-1"><a class="header-anchor" href="#_32、缓存-究竟选redis-还是memcache" aria-hidden="true">#</a> 32、缓存：究竟选redis，还是memcache？</h2><ul><li>no32，什么时候选 Redis，什么时候选 memcache？ <ul><li>选 Redis <ul><li>1.复杂数据结构</li><li>2.持久化 <ul><li>优点是，缓存挂了再重启，可以快速恢复，不需要 cache 的预热功能</li><li>但不建议使用，因为可能会导致缓存和数据库不一致</li></ul></li><li>3.天然高可用，支持主从复制，读写分离，提供了 sentinel 的集群管理工具，能够实现主从服务的监控，故障自动转移，mc 需要二次开发，但绝大多数缓存不需要做高可用</li><li>4.存储内容比较大，mc 的 kv 存储的 value 最大只支持 1M</li></ul></li><li>选 memcache <ul><li>纯 kv</li><li>原因： <ul><li>1.预分配内存池</li><li>2.redis 的 VM 机制更慢</li><li>3.redis 的 CPU 计算复杂</li><li>4.多线程可利用多核</li></ul></li></ul></li><li>其它 <ul><li>1.redis 源码可读性好</li><li>2.redis 和 mc 都需要手动水平切分</li></ul></li></ul></li></ul>',12),h=[a];function s(c,n){return i(),e("div",null,h)}const d=l(t,[["render",s],["__file","arch-sj-6.html.vue"]]);export{d as default};
