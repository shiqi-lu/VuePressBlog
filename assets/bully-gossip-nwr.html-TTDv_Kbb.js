import{_ as i,o as a,c as l,e}from"./app-n0xwCUxG.js";const h={},r=e('<h2 id="导语" tabindex="-1"><a class="header-anchor" href="#导语" aria-hidden="true">#</a> 导语</h2><h3 id="为什么要有分布式选举" tabindex="-1"><a class="header-anchor" href="#为什么要有分布式选举" aria-hidden="true">#</a> 为什么要有分布式选举？</h3><ul><li>主节点在一个分布式集群中负责对其它节点的协调和管理，它的存在可以保证其它节点的有序运行，以及数据库集群中的写入数据在每个节点上的一致性。（一致性是指，数据在每个集群节点中都是一样的，不存在不同的情况）</li></ul><h3 id="分布式选举问题的本质是什么" tabindex="-1"><a class="header-anchor" href="#分布式选举问题的本质是什么" aria-hidden="true">#</a> 分布式选举问题的本质是什么？</h3><ul><li>传统的分布式共识方法，主要是基于多数投票策略实现的</li></ul><h3 id="什么是分布式共识" tabindex="-1"><a class="header-anchor" href="#什么是分布式共识" aria-hidden="true">#</a> 什么是分布式共识？</h3><ul><li>在多个节点均可独自操作或记录的情况下，使得所有节点针对某个状态达成一致的过程</li><li>本质是“求同存异”</li></ul><h3 id="一致性和共识的区别是什么" tabindex="-1"><a class="header-anchor" href="#一致性和共识的区别是什么" aria-hidden="true">#</a> 一致性和共识的区别是什么？</h3><ul><li>一致性：分布式系统中的多个节点之间，给定一系列的操作，在约定协议的保障下，对外界呈现的数据或状态时一致的</li><li>共识：分布式系统中多个节点之间，彼此对某个状态达成一致结果的过程</li><li>一致性强调结果，共识强调达成一致的过程，共识算法是保障系统满足不同程度一致性的核心技术</li></ul><h3 id="拜占庭容错算法和非拜占庭容错算法" tabindex="-1"><a class="header-anchor" href="#拜占庭容错算法和非拜占庭容错算法" aria-hidden="true">#</a> 拜占庭容错算法和非拜占庭容错算法</h3><ul><li>拜占庭将军问题描述的是最困难的，也是最复杂的一种分布式故障场景，除了存在故障行为，还存在恶意行为的一个场景。必须使用拜占庭容错算法（Byzantine Fault Tolerance，BFT）。还有：PBFT 算法，PoW 算法</li><li>在计算机分布式系统中，最常用的是非拜占庭容错算法，即故障容错算法（Crash Fault Tolerance，CFT）。CFT 解决的是分布式的系统中存在故障，但不存在恶意节点的场景下的共识问题。这个场景可能会丢失消息，或者有消息重复，但不存在错误消息，或者伪造消息的情况。常见的算法有 Paxos 算法、Raft 算法、ZAB 协议</li></ul><h2 id="bully" tabindex="-1"><a class="header-anchor" href="#bully" aria-hidden="true">#</a> Bully</h2><h3 id="选举原则" tabindex="-1"><a class="header-anchor" href="#选举原则" aria-hidden="true">#</a> 选举原则</h3><ul><li>“长者为大”，在所有活着的节点中，选取ID最大的节点作为主节点</li></ul><h3 id="假设条件" tabindex="-1"><a class="header-anchor" href="#假设条件" aria-hidden="true">#</a> 假设条件</h3><ul><li>集群中每个节点均知道其它节点的ID</li></ul><h3 id="节点有哪两种角色-初始角色和变化过程是怎样的" tabindex="-1"><a class="header-anchor" href="#节点有哪两种角色-初始角色和变化过程是怎样的" aria-hidden="true">#</a> 节点有哪两种角色？初始角色和变化过程是怎样的？</h3><ul><li>普通节点和主节点</li><li>初始化时，所有节点都是平等的，都是普通节点，并且都有成为主节点的权利</li><li>当选主成功后，有且仅有一个节点成为主节点，其它节点都是普通节点。当且仅当主节点故障或与其它节点失去联系后，才会重新选主</li></ul><h3 id="选举过程中用到的3种消息是哪些" tabindex="-1"><a class="header-anchor" href="#选举过程中用到的3种消息是哪些" aria-hidden="true">#</a> 选举过程中用到的3种消息是哪些？</h3><ul><li>Election消息：用于发起选举</li><li>Alive消息：对Election消息的应答</li><li>Victory消息：竞选成功的主节点向其它节点发送的宣誓主权的消息</li></ul><h3 id="选举过程是怎样" tabindex="-1"><a class="header-anchor" href="#选举过程是怎样" aria-hidden="true">#</a> 选举过程是怎样？</h3><ul><li>1.集群中每个节点判断自己的ID是否为当前活着的节点中ID最大的，如果是，则直接向其它节点发送Victory消息，宣誓自己的主权</li><li>2.如果自己不是当前活着的节点中ID最大的，则向比自己大的所有节点发送Election消息，并等待其它节点的回复</li><li>3.若在给定的时间范围内，本节点没有收到其它节点回复的Alive消息，则认为自己成为主节点，并向其它节点发送Victory消息，宣誓自己成为主节点；若接收到来自比自己ID大的节点的Alive消息，则等待其它节点发送Victory消息</li><li>4.若本节点收到比自己ID小的节点发送的Election消息，则回复一个Alive消息，告知其它节点，我比你大，重新选举</li><li><img src="https://img.shiqi-lu.tech/20200905201614.png" alt=""></li></ul><h3 id="优点" tabindex="-1"><a class="header-anchor" href="#优点" aria-hidden="true">#</a> 优点</h3><ul><li>选举速度快、算法复杂度低、简单易实现</li></ul><h3 id="缺点" tabindex="-1"><a class="header-anchor" href="#缺点" aria-hidden="true">#</a> 缺点</h3><ul><li>1.需要每个节点有全局的节点信息，因此额外信息存储较多</li><li>2.任意一个比当前主节点ID大的新节点或节点故障后恢复加入集群的时候，都可能会触发重新选举，成为新的主节点，如果该节点频繁退出、加入集群，就会导致频繁切主</li></ul><h3 id="应用例子" tabindex="-1"><a class="header-anchor" href="#应用例子" aria-hidden="true">#</a> 应用例子</h3><ul><li>MongoDB的副本集故障转移功能：采用最后操作时间戳来表示ID，时间戳最新的节点其ID，时间戳最新的节点ID最大，即时间戳最新的、活着的节点是主节点</li></ul><h2 id="gossip" tabindex="-1"><a class="header-anchor" href="#gossip" aria-hidden="true">#</a> Gossip</h2><h3 id="定义" tabindex="-1"><a class="header-anchor" href="#定义" aria-hidden="true">#</a> 定义</h3><ul><li>Gossip 协议，利用一种随机、带有传染性的方式，将信息传播到整个网络中，并在一定时间内，使得系统内的所有节点数据一致(实现最终一致性)，在极端情况下（比如集群中只有一个节点在运行）也能运行</li></ul><h3 id="三要素" tabindex="-1"><a class="header-anchor" href="#三要素" aria-hidden="true">#</a> 三要素</h3><ul><li>直接邮寄(Direct Mail)</li><li>反熵(Anti-entropy)</li><li>谣言传播(Rumor mongering)</li></ul><h3 id="直接邮寄" tabindex="-1"><a class="header-anchor" href="#直接邮寄" aria-hidden="true">#</a> 直接邮寄</h3><ul><li>直接发送更新数据，当数据发送失败时，将数据缓存下来，然后重传。直接邮寄虽然实现起来比较容易，数据同步也很及时，但可能会因为缓存队列满了而丢数据。即只采用直接邮寄是无法实现最终一致性的</li></ul><h3 id="反熵" tabindex="-1"><a class="header-anchor" href="#反熵" aria-hidden="true">#</a> 反熵</h3><ul><li>集群中的节点，每隔一段时间就随机选择某个其它节点，然后通过互相交换自己的所有数据来消除两者之间的差异，实现数据的最终一致性</li><li><img src="https://img.shiqi-lu.tech/20210224182702.png" alt=""></li><li>如上图，节点A通过反熵的方式，修复了节点 D 中缺失的数据</li><li>注意，因为反熵熵需要节点两两交换和比对自己所有的数据，执行反熵时通讯成本会很高，不建议频繁执行，可通过引入校验和(Checksum)等机制，降低需要对比的数据量和通讯消息</li><li>执行反熵时相关的节点都是已知的，而且节点数量不能太多，如果是一个动态变化或节点数比较多的分布式环境，这时反熵就不适用了，该用谣言传播</li></ul><h3 id="反熵修复节点缺失数据的3种方式" tabindex="-1"><a class="header-anchor" href="#反熵修复节点缺失数据的3种方式" aria-hidden="true">#</a> 反熵修复节点缺失数据的3种方式</h3><ul><li>以下图中，2 个数据副本的不一致为例</li><li><img src="https://img.shiqi-lu.tech/20210224183252.png" alt=""></li><li>推：将自己的所有副本数据，推给对方，修复对方副本中的熵</li><li><img src="https://img.shiqi-lu.tech/20210224183330.png" alt=""></li><li>拉：拉取对方的所有副本数据，修复自己副本中的熵</li><li><img src="https://img.shiqi-lu.tech/20210224183401.png" alt=""></li><li>推拉：同时修复自己副本和对方副本中的熵</li><li><img src="https://img.shiqi-lu.tech/20210224183422.png" alt=""></li></ul><h3 id="谣言传播" tabindex="-1"><a class="header-anchor" href="#谣言传播" aria-hidden="true">#</a> 谣言传播</h3><ul><li>当一个节点有了新数据后，这个节点编程活跃状态，并周期性地联系其他节点向其发送新数据，直到所有的节点都存储了该新数据</li><li><img src="https://img.shiqi-lu.tech/20210224182841.png" alt=""></li><li>如图，节点 A 向节点 B、D 发送新数据，节点 B 收到新数据后，变成活跃节点，然后节点 B 向节点 C、D 发送新数据。谣言传播非常具有传染性，它适合动态变化的分布式系统</li></ul><h2 id="quorum-nwr" tabindex="-1"><a class="header-anchor" href="#quorum-nwr" aria-hidden="true">#</a> Quorum NWR</h2><h3 id="最终一致性和强一致性有什么区别" tabindex="-1"><a class="header-anchor" href="#最终一致性和强一致性有什么区别" aria-hidden="true">#</a> 最终一致性和强一致性有什么区别</h3><ul><li>强一致性能保证写操作完成后，任何后续访问都能读到更新后的值</li><li>最终一致性只能保证如果对某个对象没有新的写操作了，最终所有后续访问都能读到相同的最近更新的值，即写操作完成后，后续访问可能会读到旧数据</li></ul><h3 id="三要素-1" tabindex="-1"><a class="header-anchor" href="#三要素-1" aria-hidden="true">#</a> 三要素</h3><ul><li>N：副本数，又叫复制因子(Replication Factor)</li><li>W：写一致性级别(Write Consistency Level)，表示成功完成W个副本更新，才完成写操作</li><li>R：读一致性级别(Read Consistency Level)，表示读取一个数据对象时需要读R个副本，即，读取指定数据时，要读 R 副本，然后返回 R 个副本中最新的那份数据</li><li>注意：无论客户端如何执行读操作，哪怕它访问的是写操作未强制更新副本数据的节点（比如节点 B），但因为 W(2) + R(2) &gt; N(3)，也就是说，访问节点 B，执行读操作时，因为要读 2 份数据副本，所以除了节点 B 上的 DATA-2，还会读取节点 A 或节点 C 上的 DATA-2，就像上图的样子（比如节点 C 上的 DATA-2），而节点 A 和节点 C 的 DATA-2 数据副本是强制更新成功的。这个时候，返回给客户端肯定是最新的那份数据</li></ul><h3 id="n、w、r-值的不同组合-会产生哪两种不同的一致性效果" tabindex="-1"><a class="header-anchor" href="#n、w、r-值的不同组合-会产生哪两种不同的一致性效果" aria-hidden="true">#</a> N、W、R 值的不同组合，会产生哪两种不同的一致性效果？</h3><ul><li>当 W + R &gt; N 时，对于客户端来说，整个系统能保证强一致性，一定能返回更新后的那份数据</li><li>当 W + R &lt; N 时，对于客户端来说，整个系统只能保证最终一致性，可能会返回旧数据</li></ul><h3 id="any、one、quorum、all-这4种写一致性级别-具体的含义" tabindex="-1"><a class="header-anchor" href="#any、one、quorum、all-这4种写一致性级别-具体的含义" aria-hidden="true">#</a> any、one、quorum、all 这4种写一致性级别，具体的含义</h3><ul><li>any：任何一个节点写入成功后，或者接收节点已将数据写入Hinted-handoff缓存(即写其他节点失败后，本地节点上缓存写失败数据的队列) 后，就会返回成功给客户端</li><li>one：任何一个节点写入成功后，立即返回成功给客户端，，不包括成功写入到 Hinted-handoff 缓存</li><li>quorum：当大多数节点写入成功后，就会返回成功给客户端。此选项仅在副本数大于 2 时才有意义，否则等效于 all</li><li>all：仅在所有节点都写入成功后，返回成功</li></ul><h2 id="参考" tabindex="-1"><a class="header-anchor" href="#参考" aria-hidden="true">#</a> 参考</h2><ul><li>分布式协议与算法实战-极客时间</li><li>分布式技术原理与算法解析-极客时间</li><li>软件架构设计 大型网站技术架构与业务架构融合之道</li></ul>',52),d=[r];function n(t,u){return a(),l("div",null,d)}const c=i(h,[["render",n],["__file","bully-gossip-nwr.html.vue"]]);export{c as default};
