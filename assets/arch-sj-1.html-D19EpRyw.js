import{_ as l,o as i,c as e,e as n}from"./app-n0xwCUxG.js";const u={},a=n(`<h2 id="_2、技术选型-创业初期-技术如何选型" tabindex="-1"><a class="header-anchor" href="#_2、技术选型-创业初期-技术如何选型" aria-hidden="true">#</a> 2、技术选型：创业初期，技术如何选型</h2><ul><li>no2：创业初期架构特点、选型依据、选型建议是什么？ <ul><li>特点： <ul><li>1.单机系统(All in one)</li><li>2.程序耦合(All in one)</li><li>3.逻辑核心是 CURD</li></ul></li><li><img src="https://img.shiqi-lu.tech/20210823205116.png" alt=""></li><li>主要依据：选择技术合伙人会的，熟悉的，是早期技术选型的</li><li>选型建议： <ul><li>PHP体系：Linux、Apache、MySQL、PHP</li><li>Java 体系：Linux、Tomcat、MySQL、Java</li></ul></li></ul></li><li>no2：创业初期工程师的主要矛盾是什么？如何解决？ <ul><li>矛盾：业务开发效率与质量低，CURD 频繁出错</li><li>解决：尽早引入 DAO/ORM 技术</li><li>DAO(Data Access Object)：像对象一样访问数据</li><li>ORM(Object Relation Mapping)：简化数据库查询过程</li><li><img src="https://img.shiqi-lu.tech/20210823205532.png" alt=""></li></ul></li></ul><h2 id="_3、技术选型-框架组件要不要自研-什么时候自研" tabindex="-1"><a class="header-anchor" href="#_3、技术选型-框架组件要不要自研-什么时候自研" aria-hidden="true">#</a> 3、技术选型：框架组件要不要自研，什么时候自研？</h2><ul><li>no3：框架组件要不要自研，什么时候自研？有哪 4 个观点？ <ul><li>1.早期不要自研，后期适当自定义</li><li>2.随着规模的扩大，要控制技术栈</li><li>3.建议浅浅的封装一层</li><li>4.随着业务规模，研发团队进一步扩大，适当造一些轮子</li></ul></li><li>no3：为什么说早期不建议自研？ <ul><li>1.早期的业务以快速迭代为最高优先级，快速实现功能，让公司活下来最重要</li><li>2.技术栈选择技术合伙人最熟悉的 <ul><li>研发语言：熟PHP选PHP，熟Java选Java</li><li>数据库：熟MySQL选MySQL，熟SQL-server选SQL-server</li><li>框架组件：熟Ruby on Rails选ROR，熟ThinkPHP选ThinkPHP，熟SSH选SSH</li></ul></li><li>3.此时技术栈的选择对合伙人的技术视野有要求，能在未来少踩坑</li></ul></li><li>no3：为什么要控制技术栈？ <ul><li>1.绝对不能每个人想用什么就用什么，否则会造成混乱</li><li>2.即使用开源，技术栈也尽量统一</li></ul></li><li>no3：什么叫「浅浅封装一层」？好处是什么？<div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>String Memcache::get(String key)
String Memcache::set(String key, String value)
String Memcache::del(String key)

String 58DaojiaKV::get(String key) {
    String result = Memcache::get(key);
    return result;
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>好处 <ul><li>对调用方屏蔽底层实现细节</li><li>当底层变化的时候，调用方改动很小</li><li>能很方便实现统一的功能，如时间统计等</li></ul></li></ul></li><li>no3：为什么说随着业务规模和研发团队的扩大可以适当造一些轮子？而不能全部使用开源？ <ul><li>不同技术团队，痛点是相似的</li><li>开源解决不了全部个性化需求 <ul><li>有站点，监控服务的可用性，处理时间监控需求</li><li>有告警需求</li><li>有自动化发布，自动化运维需求</li><li>有服务治理，服务自动发现需求</li><li>有调用链跟踪需求</li><li>有SQL监控需求</li><li>有系统层面数据收集与可视化展现的需求</li></ul></li><li>自研解决痛点，更贴合团队实际情况 <ul><li>开源框架/组件太重了，我们需要的可能只是一个轻量级的框架/组件</li><li>开源框架/组件，只能满足我们的一部分需求</li><li>不了解开源框架/组件的设计理念，要二次开发成本更高</li><li>有些通用的需求是和业务紧密结合的，开源框架/组件可能满足不了</li></ul></li></ul></li></ul><h2 id="_4、容量设计-流量高低-对架构究竟有什么影响" tabindex="-1"><a class="header-anchor" href="#_4、容量设计-流量高低-对架构究竟有什么影响" aria-hidden="true">#</a> 4、容量设计：流量高低，对架构究竟有什么影响？</h2><ul><li>no4：什么时候要进行容量评估？ <ul><li>1.容量有质变性增长</li><li>2.临时运营活动</li><li>3.新系统上线</li></ul></li><li>no4：哪些指标要进行容量预估？ <ul><li>看具体业务，对应到系统侧的主要矛盾是什么，如：</li><li>1.数据量</li><li>2.并发量，吞吐量</li><li>3.带宽</li><li>4.CPU/MEM/DISK 等</li></ul></li><li>no4：如何进行容量评估(以吞吐量为例) <ul><li>1.评估总访问量：询问产品、运营</li><li>2.评估平均访问量：总量除以总时间，一天可算 4w 秒</li><li>3.评估高峰 QPS：可根据业务曲线图来</li><li>4.评估系统、单机极限 QPS：使用压测</li><li>5.根据线上冗余度做决策：计算需求和线上冗余度差值</li></ul></li></ul><h2 id="_5、伪分布式-你以为-多机就是分布式" tabindex="-1"><a class="header-anchor" href="#_5、伪分布式-你以为-多机就是分布式" aria-hidden="true">#</a> 5、伪分布式：你以为，多机就是分布式？</h2><ul><li>no5：随着流量的提升，早期系统最先遇到的两大问题是什么？如何分析系统特点与瓶颈？ <ul><li>现象：人多的时候会卡(即慢，性能下降)，压力会导致宕机(即一挂全挂，耦合严重)</li><li>瓶颈分析：网络带宽、内存、CPU 计算、磁盘 IO</li><li>初步结论：ALL in one 导致单机资源称为瓶颈</li></ul></li><li>no5：架构早期最快速地解决「单机资源瓶颈」问题的思路？做法？原因？ <ul><li>思路： <ul><li>增加硬件资源(时间短)，避免大规模代码重构(时间长)</li></ul></li><li>做法： <ul><li>把「单机」变「多机」，用最小的成本，扩展资源</li></ul></li><li>原因： <ul><li>此时最大的成本，是时间成本</li><li>能用“钱”解决的系统问题，往往不是问题</li><li>老板最不愿见到的，是解决一个系统问题， 花很长的时间(市场和投资人等不起)</li></ul></li></ul></li><li>no5：「单机」变「多机」的伪分布式的「三大分离」应该怎么做？设计思路？没解决的问题？ <ul><li><img src="https://img.shiqi-lu.tech/20210823225351.png" alt=""></li><li>三大分离 <ul><li>1.读写分离(引发读写延时新问题)：将数据库的读写请求分散到不同的数据库机器上</li><li>2.动静分离：将静态文件(css、jpg、静态页面)和动态生成的站点分离</li><li>3.前台后台分离：前台即用户访问的系统，后台即运营使用的系统</li></ul></li><li>设计思路：用最快的速度，增加硬件资源，提升系统性能，增加访问速度</li><li>没解决的问题： <ul><li>1.耦合问题：一个子系统挂了，仍然是全站挂</li><li>2.主从延时新问题：读写分离只能提升读写性能，无法降低单库数据量</li></ul></li></ul></li><li>no5：如何解决「三大分离」的耦合问题和读写延时问题？设计思路？如何操作？ <ul><li><img src="https://img.shiqi-lu.tech/20210823230403.png" alt=""></li><li>方案：业务垂直拆分，解耦</li><li>操作： <ul><li>1.业务垂直拆分</li><li>2.代码垂直拆分(子系统耦合)</li><li>3.数据库垂直拆分(数据量降低，延时缓解)</li><li>4.研发团队垂直拆分(专业化，效率提升)</li></ul></li><li>设计思路：用最快的速度，增加硬件资源，解耦</li><li>垂直拆分，会随着业务越来越复杂，不断持续地进行</li><li>存在问题 <ul><li>1.对同一个垂直站点子系统，仍然是一个「单体架构」，每一个业务都并不是高可用的，子系统的性能仍然受到单机资源的限制无法扩展</li><li>2.子系统不是高可用的，只能保证一个挂了，另一个不受影响</li></ul></li></ul></li></ul>`,8),r=[a];function s(t,c){return i(),e("div",null,r)}const h=l(u,[["render",s],["__file","arch-sj-1.html.vue"]]);export{h as default};
