import{_ as e,r as i,o as t,c as o,a as n,b as s,d as l,e as p}from"./app-n0xwCUxG.js";const c={},u=p(`<h2 id="限流的定义是什么" tabindex="-1"><a class="header-anchor" href="#限流的定义是什么" aria-hidden="true">#</a> 限流的定义是什么</h2><ul><li>限流就是对请求的速率进行限制，即限制到达系统的并发请求数，避免瞬时的大量请求击垮软件系统</li></ul><h2 id="限流算法有哪些" tabindex="-1"><a class="header-anchor" href="#限流算法有哪些" aria-hidden="true">#</a> 限流算法有哪些？</h2><ul><li>计数限流</li><li>固定窗口限流</li><li>滑动窗口限流</li><li>漏桶算法</li><li>令牌桶算法</li></ul><h2 id="计数限流算法原理、代码、优缺点" tabindex="-1"><a class="header-anchor" href="#计数限流算法原理、代码、优缺点" aria-hidden="true">#</a> 计数限流算法原理、代码、优缺点</h2><ul><li>原理 <ul><li>根据系统能同时处理的请求数，保存一个计数器，处理一个请求加一，处理完后减一，若超过阈值拒绝请求</li></ul></li><li>代码</li></ul><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code> <span class="token keyword">boolean</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token keyword">if</span> <span class="token punctuation">(</span>counter <span class="token operator">&lt;</span> threshold<span class="token punctuation">)</span> <span class="token punctuation">{</span>
         counter<span class="token operator">++</span><span class="token punctuation">;</span>
         <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
     <span class="token punctuation">}</span>
     <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span>

<span class="token keyword">boolean</span> <span class="token function">tryRelease</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>counter <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        counter<span class="token operator">--</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>优点 <ul><li>简单粗暴，单机在 java 可用 Atomic 等原子类、分布式就 Redis incr</li></ul></li><li>缺点 <ul><li>假设单机设的 1 万阈值，计数器为 0，若在 1 秒内收到 1 万个突发请求，可能超过机器的处理上限而导致机器崩溃</li></ul></li></ul><h2 id="固定窗口限流算法的原理、代码、问题" tabindex="-1"><a class="header-anchor" href="#固定窗口限流算法的原理、代码、问题" aria-hidden="true">#</a> 固定窗口限流算法的原理、代码、问题</h2><ul><li>原理 <ul><li><img src="https://img.shiqi-lu.tech/20211204112507.png" alt=""></li><li>相比于计数限流主要是多了个时间窗口的概念，计数器每过一个时间窗口就重置，规则为： <ul><li>1.请求次数小于阈值，允许访问并且计数器 +1</li><li>2.请求次数大于阈值，拒绝访问</li><li>3.这个时间窗口过了之后，计数器清零</li></ul></li><li>代码</li></ul></li></ul><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">boolean</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 获取当前时间</span>
    bool now <span class="token operator">=</span> <span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 若过了时间窗口把计数器清零</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>now <span class="token operator">-</span> lastAcquireTime <span class="token operator">&gt;</span> <span class="token class-name">TimeWindow</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        counter <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        lastAcquireTime <span class="token operator">=</span> now<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>counter <span class="token operator">&lt;</span> threshold<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        counter<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>问题 <ul><li>无法保证限流速率，因而无法保证突然激增的流量，会遇到固定窗口临界问题，即这个算法有时会让通过请求量允许为限制的两倍</li><li>如图，限制 1 秒内最多通过 5 个请求，在第一个窗口的最后半秒内通过了 5 个请求，第二个窗口的前半秒内又通过了 5 个请求。这样看来就是在 1 秒内通过了 10 个请求</li><li><img src="https://img.shiqi-lu.tech/20211204112759.png" alt=""></li></ul></li></ul><h2 id="滑动窗口限流算法的原理、代码" tabindex="-1"><a class="header-anchor" href="#滑动窗口限流算法的原理、代码" aria-hidden="true">#</a> 滑动窗口限流算法的原理、代码</h2><ul><li>原理 <ul><li><img src="https://img.shiqi-lu.tech/20211204113156.png" alt=""></li><li>1.将时间划分为多个区间</li><li>2.在每个区间内每有一次请求就将计数器加一维持一个时间窗口，占据多个区间</li><li>3.每经过一个区间的时间，则抛弃最老的一个区间，并纳入最新的一个区间</li><li>4.如果当前窗口内的请求计数总和超过了限制数量，则本窗口内所有的请求都被丢弃</li></ul></li><li>代码 <ul><li>实现：记录每次请求的时间，统计每次请求的时间至往前一个时间窗口的请求数，如果小于阈值就记录这个请求的时间，反之拒绝</li></ul></li></ul><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">boolean</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">long</span> now <span class="token operator">=</span> <span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">long</span> counter <span class="token operator">=</span> <span class="token function">getCounterInTimeWindow</span><span class="token punctuation">(</span>now<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>counter <span class="token operator">&lt;</span> threshold<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">addToTimeWindow</span><span class="token punctuation">(</span>now<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>优点 <ul><li>避免了固定窗口计数器带来的双倍突发请求</li></ul></li><li>缺点 <ul><li>时间区间的精度越高，算法所需的空间容量就越大</li><li>无法解决短时间集中流量的突击，到流量处理不够平滑</li></ul></li></ul><h2 id="桶漏算法的原理、实现、优缺点" tabindex="-1"><a class="header-anchor" href="#桶漏算法的原理、实现、优缺点" aria-hidden="true">#</a> 桶漏算法的原理、实现、优缺点</h2><ul><li>原理 <ul><li><img src="https://img.shiqi-lu.tech/20211204114457.png" alt=""></li><li>水滴持续漏到桶中，底部定速流出，如果桶空了则停止漏水，如果满了多余的水会被直接抛弃</li></ul></li><li>实现 <ul><li>使用队列，服务的请求会存在队列中，服务的提供方按照固定的速率从队列中取出请求并执行，过多的请求则放在队列中排队或直接拒绝</li></ul></li><li>优点 <ul><li>宽进严出，无论请求数量和速率多大，都能按照固定速率流出，流量处理非常平滑</li></ul></li><li>缺点 <ul><li>当短时间内有大量的突发请求时，即便此时服务器没有任何负载，每个请求也都得在队列中等待一段时间才能被响应</li></ul></li></ul><h2 id="令牌桶算法的原理、优缺点" tabindex="-1"><a class="header-anchor" href="#令牌桶算法的原理、优缺点" aria-hidden="true">#</a> 令牌桶算法的原理、优缺点</h2><ul><li>原理 <ul><li><img src="https://img.shiqi-lu.tech/20211204121242.png" alt=""></li><li>以固定速率生成令牌存入到令牌桶中</li><li>如果令牌数量超过桶的限制则直接丢弃</li><li>当请求到达是，会先从令牌桶中取令牌，取到了令牌的请求可以执行，如果桶空了，那么取令牌的请求会被直接丢弃</li></ul></li><li>优点 <ul><li>能够将所有的请求平均分布到时间区间内，又能接受服务器能够承受范围内的突发请求</li></ul></li></ul><h2 id="参考" tabindex="-1"><a class="header-anchor" href="#参考" aria-hidden="true">#</a> 参考</h2>`,21),r={href:"https://segmentfault.com/a/1190000023552181",target:"_blank",rel:"noopener noreferrer"},d={href:"https://snailclimb.gitee.io/javaguide/#/docs/high-availability/limit-request",target:"_blank",rel:"noopener noreferrer"},k=n("li",null,"极客时间-分布式技术原理与算法解析 29 讲",-1),v={href:"https://www.infoq.cn/article/Qg2tX8fyw5Vt-f3HH673",target:"_blank",rel:"noopener noreferrer"};function h(m,b){const a=i("ExternalLinkIcon");return t(),o("div",null,[u,n("ul",null,[n("li",null,[n("a",r,[s("图解+代码|常见限流算法以及限流在单机分布式场景下的思考"),l(a)])]),n("li",null,[n("a",d,[s("限流算法有哪些？"),l(a)])]),k,n("li",null,[n("a",v,[s("分布式服务限流实战，已经为你排好坑了"),l(a)])])])])}const f=e(c,[["render",h],["__file","throttling-algorithm.html.vue"]]);export{f as default};
